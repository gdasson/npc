// Code generated by hand for this reference implementation. In a real kubebuilder project,
// run controller-gen to generate deep-copy methods.
//
//go:build !ignore_autogenerated
// +build !ignore_autogenerated

package v1alpha1

import (
    metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
    runtime "k8s.io/apimachinery/pkg/runtime"
)

func (in *NodePatchRun) DeepCopyInto(out *NodePatchRun) {
    *out = *in
    out.TypeMeta = in.TypeMeta
    in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
    out.Spec = in.Spec

    if in.Spec.ImportantPodSelectors != nil {
        out.Spec.ImportantPodSelectors = append([]NamespacedLabelSelector{}, in.Spec.ImportantPodSelectors...)
    }
    if in.Spec.RequiredNodeDaemonPodSelectors != nil {
        out.Spec.RequiredNodeDaemonPodSelectors = append([]NamespacedLabelSelector{}, in.Spec.RequiredNodeDaemonPodSelectors...)
    }
    if in.Spec.LabelTransfer != nil {
        lt := *in.Spec.LabelTransfer
        if in.Spec.LabelTransfer.Keys != nil {
            lt.Keys = append([]string{}, in.Spec.LabelTransfer.Keys...)
        }
        if in.Spec.LabelTransfer.Prefixes != nil {
            lt.Prefixes = append([]string{}, in.Spec.LabelTransfer.Prefixes...)
        }
        if in.Spec.LabelTransfer.ExcludeKeys != nil {
            lt.ExcludeKeys = append([]string{}, in.Spec.LabelTransfer.ExcludeKeys...)
        }
        out.Spec.LabelTransfer = &lt
    }
    if in.Spec.AutoscalerControl != nil {
        ac := *in.Spec.AutoscalerControl
        out.Spec.AutoscalerControl = &ac
    }
    if in.Spec.Provider.AWS != nil {
        aws := *in.Spec.Provider.AWS
        if in.Spec.Provider.AWS.ExtraTags != nil {
            m := map[string]string{}
            for k, v := range in.Spec.Provider.AWS.ExtraTags {
                m[k] = v
            }
            aws.ExtraTags = m
        }
        out.Spec.Provider.AWS = &aws
    }

    out.Status = in.Status
    if in.Status.Conditions != nil {
        out.Status.Conditions = append([]metav1.Condition{}, in.Status.Conditions...)
    }
    if in.Status.Plan != nil {
        p := *in.Status.Plan
        if in.Status.Plan.Candidates != nil {
            p.Candidates = append([]PlannedNode{}, in.Status.Plan.Candidates...)
        }
        if in.Status.Plan.Partitions != nil {
            p.Partitions = append([]Partition{}, in.Status.Plan.Partitions...)
            for i := range p.Partitions {
                if in.Status.Plan.Partitions[i].Nodes != nil {
                    p.Partitions[i].Nodes = append([]string{}, in.Status.Plan.Partitions[i].Nodes...)
                }
            }
        }
        out.Status.Plan = &p
    }
    if in.Status.Autoscaler != nil {
        a := *in.Status.Autoscaler
        if in.Status.Autoscaler.Targets != nil {
            a.Targets = append([]AutoscalerTargetStatus{}, in.Status.Autoscaler.Targets...)
        }
        out.Status.Autoscaler = &a
    }
}

func (in *NodePatchRun) DeepCopy() *NodePatchRun {
    if in == nil {
        return nil
    }
    out := new(NodePatchRun)
    in.DeepCopyInto(out)
    return out
}

func (in *NodePatchRun) DeepCopyObject() runtime.Object {
    if c := in.DeepCopy(); c != nil {
        return c
    }
    return nil
}

func (in *NodePatchRunList) DeepCopyInto(out *NodePatchRunList) {
    *out = *in
    out.TypeMeta = in.TypeMeta
    in.ListMeta.DeepCopyInto(&out.ListMeta)
    if in.Items != nil {
        out.Items = make([]NodePatchRun, len(in.Items))
        for i := range in.Items {
            in.Items[i].DeepCopyInto(&out.Items[i])
        }
    }
}

func (in *NodePatchRunList) DeepCopy() *NodePatchRunList {
    if in == nil {
        return nil
    }
    out := new(NodePatchRunList)
    in.DeepCopyInto(out)
    return out
}

func (in *NodePatchRunList) DeepCopyObject() runtime.Object {
    if c := in.DeepCopy(); c != nil {
        return c
    }
    return nil
}

func (in *NodePatchTask) DeepCopyInto(out *NodePatchTask) {
    *out = *in
    out.TypeMeta = in.TypeMeta
    in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)

    out.Spec = in.Spec
    if in.Spec.ImportantPodSelectors != nil {
        out.Spec.ImportantPodSelectors = append([]NamespacedLabelSelector{}, in.Spec.ImportantPodSelectors...)
    }
    if in.Spec.RequiredNodeDaemonPodSelectors != nil {
        out.Spec.RequiredNodeDaemonPodSelectors = append([]NamespacedLabelSelector{}, in.Spec.RequiredNodeDaemonPodSelectors...)
    }
    if in.Spec.LabelTransfer != nil {
        lt := *in.Spec.LabelTransfer
        if in.Spec.LabelTransfer.Keys != nil {
            lt.Keys = append([]string{}, in.Spec.LabelTransfer.Keys...)
        }
        if in.Spec.LabelTransfer.Prefixes != nil {
            lt.Prefixes = append([]string{}, in.Spec.LabelTransfer.Prefixes...)
        }
        if in.Spec.LabelTransfer.ExcludeKeys != nil {
            lt.ExcludeKeys = append([]string{}, in.Spec.LabelTransfer.ExcludeKeys...)
        }
        out.Spec.LabelTransfer = &lt
    }

    out.Status = in.Status
    if in.Status.ProviderDetails != nil {
        pd := *in.Status.ProviderDetails
        if in.Status.ProviderDetails.AWS != nil {
            aws := *in.Status.ProviderDetails.AWS
            pd.AWS = &aws
        }
        out.Status.ProviderDetails = &pd
    }
    if in.Status.StableSince != nil {
        t := *in.Status.StableSince
        out.Status.StableSince = &t
    }
}

func (in *NodePatchTask) DeepCopy() *NodePatchTask {
    if in == nil {
        return nil
    }
    out := new(NodePatchTask)
    in.DeepCopyInto(out)
    return out
}

func (in *NodePatchTask) DeepCopyObject() runtime.Object {
    if c := in.DeepCopy(); c != nil {
        return c
    }
    return nil
}

func (in *NodePatchTaskList) DeepCopyInto(out *NodePatchTaskList) {
    *out = *in
    out.TypeMeta = in.TypeMeta
    in.ListMeta.DeepCopyInto(&out.ListMeta)
    if in.Items != nil {
        out.Items = make([]NodePatchTask, len(in.Items))
        for i := range in.Items {
            in.Items[i].DeepCopyInto(&out.Items[i])
        }
    }
}

func (in *NodePatchTaskList) DeepCopy() *NodePatchTaskList {
    if in == nil {
        return nil
    }
    out := new(NodePatchTaskList)
    in.DeepCopyInto(out)
    return out
}

func (in *NodePatchTaskList) DeepCopyObject() runtime.Object {
    if c := in.DeepCopy(); c != nil {
        return c
    }
    return nil
}
