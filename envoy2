Got it — you’ll end up with two separate repos:
	1.	Repo A: mutating webhook + init binary (injection plumbing only)
	2.	Repo B: ext-proc service (OAuth/ForgeRock + policy logic only)

They share a contract: a single per-app egress.yaml stored in a ConfigMap, but each repo keeps its own copy of the schema structs (no shared Go module required).

Below is repo-ready code for both.

⸻

Repo A — egress-injector-webhook

What this repo contains
	•	webhook binary: MutatingAdmissionWebhook that injects:
	•	egress-init initContainer (iptables + writes /work/envoy/envoy.yaml)
	•	envoy sidecar (reads /etc/envoy/envoy.yaml from shared emptyDir)
	•	ext-proc sidecar (reads /etc/egress/egress.yaml)
	•	mounts: ConfigMap + emptyDir + kafka Secret + forgerock Secret env var
	•	egress-init binary: reads /etc/egress/egress.yaml, renders Envoy config, installs iptables

Contract paths
	•	ConfigMap mounted to: /etc/egress/egress.yaml
	•	emptyDir shared:
	•	init writes: /work/envoy/envoy.yaml
	•	envoy reads: /etc/envoy/envoy.yaml

⸻

A1) Repo A layout

egress-injector-webhook/
  cmd/
    webhook/
      main.go
    egress-init/
      main.go
  internal/
    policy/
      policy.go
    ipt/
      ipt.go
    render/
      render.go
  deploy/
    webhook/
      namespace.yaml
      deployment.yaml
      service.yaml
      mutatingwebhookconfiguration.yaml
  Dockerfile.webhook
  Dockerfile.egress-init
  go.mod
  README.md


⸻

A2) go.mod

module example.com/egress-injector-webhook

go 1.22

require (
	github.com/coreos/go-iptables v0.8.0
	gopkg.in/yaml.v3 v3.0.1
	google.golang.org/grpc v1.66.2
	k8s.io/api v0.30.3
	k8s.io/apimachinery v0.30.3
)


⸻

A3) internal/policy/policy.go (schema for egress.yaml)

package policy

import "gopkg.in/yaml.v3"
import "os"

type Config struct {
	App struct {
		Name string `yaml:"name"`
	} `yaml:"app"`

	Ports struct {
		EnvoyHTTPListener  int `yaml:"envoy_http_listener"`
		EnvoyKafkaListener int `yaml:"envoy_kafka_listener"`
		ExtProcGRPC        int `yaml:"ext_proc_grpc"`
	} `yaml:"ports"`

	HTTP struct {
		InterceptPort  int  `yaml:"intercept_port"`   // default 80
		UpgradeToHTTPS bool `yaml:"upgrade_to_https"` // default true

		TrustedCAFile string `yaml:"trusted_ca_file"`
		DFP           struct {
			MaxHosts        int    `yaml:"max_hosts"`
			DNSLookupFamily string `yaml:"dns_lookup_family"`
		} `yaml:"dfp"`

		ForgeRock struct {
			Enabled        bool   `yaml:"enabled"`
			ExtProcTimeout string `yaml:"ext_proc_timeout"`
		} `yaml:"forgerock"`
	} `yaml:"http"`

	Kafka struct {
		Enabled     bool  `yaml:"enabled"`
		OriginalDst bool  `yaml:"original_dst"`
		Ports       []int `yaml:"ports"`
		TLS         struct {
			ClientCert string `yaml:"client_cert"`
			ClientKey  string `yaml:"client_key"`
			CACert     string `yaml:"ca_cert"`
		} `yaml:"tls"`
	} `yaml:"kafka"`
}

func Load(path string) (*Config, error) {
	b, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	var c Config
	if err := yaml.Unmarshal(b, &c); err != nil {
		return nil, err
	}
	applyDefaults(&c)
	return &c, nil
}

func applyDefaults(c *Config) {
	if c.Ports.EnvoyHTTPListener == 0 {
		c.Ports.EnvoyHTTPListener = 15001
	}
	if c.Ports.EnvoyKafkaListener == 0 {
		c.Ports.EnvoyKafkaListener = 15006
	}
	if c.Ports.ExtProcGRPC == 0 {
		c.Ports.ExtProcGRPC = 9000
	}
	if c.HTTP.InterceptPort == 0 {
		c.HTTP.InterceptPort = 80
	}
	if c.HTTP.TrustedCAFile == "" {
		c.HTTP.TrustedCAFile = "/etc/ssl/certs/ca-bundle.crt"
	}
	if c.HTTP.DFP.MaxHosts == 0 {
		c.HTTP.DFP.MaxHosts = 10000
	}
	if c.HTTP.DFP.DNSLookupFamily == "" {
		c.HTTP.DFP.DNSLookupFamily = "V4_ONLY"
	}
	// default true unless explicitly false (yaml bool default is false; so assume true for your pattern)
	c.HTTP.UpgradeToHTTPS = true

	// default lanes enabled unless explicitly set false in yaml (same caveat)
	c.Kafka.Enabled = true
	c.Kafka.OriginalDst = true

	if c.Kafka.TLS.ClientCert == "" {
		c.Kafka.TLS.ClientCert = "/etc/envoy/certs/tls.crt"
	}
	if c.Kafka.TLS.ClientKey == "" {
		c.Kafka.TLS.ClientKey = "/etc/envoy/certs/tls.key"
	}
	if c.Kafka.TLS.CACert == "" {
		c.Kafka.TLS.CACert = "/etc/envoy/certs/ca.crt"
	}
	if c.HTTP.ForgeRock.ExtProcTimeout == "" {
		c.HTTP.ForgeRock.ExtProcTimeout = "0.2s"
	}
}


⸻

A4) internal/ipt/ipt.go (iptables redirect)

package ipt

import (
	"strconv"

	"github.com/coreos/go-iptables/iptables"
)

type Params struct {
	EnvoyUID          int
	ExtProcUID        int
	EnvoyHTTPPort     int
	EnvoyKafkaPort    int
	HTTPInterceptPort int
	KafkaPorts        []int
}

func Install(p Params) error {
	ipt, err := iptables.New()
	if err != nil {
		return err
	}
	const table = "nat"
	const chain = "ENVOY_OUTBOUND"

	_ = ipt.NewChain(table, chain)
	if err := ipt.ClearChain(table, chain); err != nil {
		return err
	}

	// localhost
	_ = ipt.AppendUnique(table, chain, "-d", "127.0.0.1/32", "-j", "RETURN")
	// exclude envoy/ext-proc uids (avoid loops)
	_ = ipt.AppendUnique(table, chain, "-m", "owner", "--uid-owner", strconv.Itoa(p.EnvoyUID), "-j", "RETURN")
	_ = ipt.AppendUnique(table, chain, "-m", "owner", "--uid-owner", strconv.Itoa(p.ExtProcUID), "-j", "RETURN")
	// exclude DNS
	_ = ipt.AppendUnique(table, chain, "-p", "udp", "--dport", "53", "-j", "RETURN")
	_ = ipt.AppendUnique(table, chain, "-p", "tcp", "--dport", "53", "-j", "RETURN")

	// kafka ports
	for _, kp := range p.KafkaPorts {
		if kp <= 0 {
			continue
		}
		_ = ipt.AppendUnique(table, chain, "-p", "tcp", "--dport", strconv.Itoa(kp), "-j", "REDIRECT", "--to-ports", strconv.Itoa(p.EnvoyKafkaPort))
	}

	// http intercept port
	_ = ipt.AppendUnique(table, chain, "-p", "tcp", "--dport", strconv.Itoa(p.HTTPInterceptPort), "-j", "REDIRECT", "--to-ports", strconv.Itoa(p.EnvoyHTTPPort))

	// hook OUTPUT once
	_ = ipt.AppendUnique(table, "OUTPUT", "-p", "tcp", "-j", chain)

	return nil
}


⸻

A5) internal/render/render.go (renders Envoy config)

package render

import (
	"bytes"
	"strings"
	"text/template"

	"example.com/egress-injector-webhook/internal/policy"
)

func EnvoyYAML(c *policy.Config) (string, error) {
	const tpl = `
node:
  id: {{.NodeID}}
  cluster: egress

admin:
  access_log_path: /tmp/admin_access.log
  address:
    socket_address: { address: 127.0.0.1, port_value: 9901 }

static_resources:
  listeners:
    - name: egress_http
      address:
        socket_address: { address: 0.0.0.0, port_value: {{.EnvoyHTTPPort}} }
      filter_chains:
        - filters:
            - name: envoy.filters.network.http_connection_manager
              typed_config:
                "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
                stat_prefix: egress_http
                normalize_path: true
                route_config:
                  name: egress_http_routes
                  virtual_hosts:
                    - name: egress
                      domains: ["*"]
                      routes:
                        - match: { prefix: "/" }
                          route: { cluster: dynamic_forward_proxy_cluster }
                http_filters:
                  - name: envoy.filters.http.set_filter_state
                    typed_config:
                      "@type": type.googleapis.com/envoy.extensions.filters.http.set_filter_state.v3.Config
                      on_request_headers:
                        - object_key: "envoy.upstream.dynamic_host"
                          format_string:
                            text_format_source:
                              inline_string: "%REQ(:AUTHORITY)%"
                        - object_key: "envoy.upstream.dynamic_port"
                          format_string:
                            text_format_source:
                              inline_string: "443"

{{- if .ForgeRockEnabled }}
                  - name: envoy.filters.http.ext_proc
                    typed_config:
                      "@type": type.googleapis.com/envoy.extensions.filters.http.ext_proc.v3.ExternalProcessor
                      grpc_service:
                        envoy_grpc:
                          cluster_name: ext-proc
                      processing_mode:
                        request_header_mode: SEND
                        response_header_mode: SKIP
                        request_body_mode: NONE
                        response_body_mode: NONE
                      message_timeout: {{.ExtProcTimeout}}
{{- end }}

                  - name: envoy.filters.http.dynamic_forward_proxy
                    typed_config:
                      "@type": type.googleapis.com/envoy.extensions.filters.http.dynamic_forward_proxy.v3.FilterConfig
                      dns_cache_config:
                        name: dfp_cache
                        dns_lookup_family: {{.DFPFamily}}
                        max_hosts: {{.DFPMaxHosts}}

                  - name: envoy.filters.http.router
                    typed_config:
                      "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router

{{- if .KafkaEnabled }}
    - name: egress_kafka
      address:
        socket_address: { address: 0.0.0.0, port_value: {{.EnvoyKafkaPort}} }
      filter_chains:
        - filters:
            - name: envoy.filters.network.tcp_proxy
              typed_config:
                "@type": type.googleapis.com/envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy
                stat_prefix: egress_kafka
                cluster: kafka_upstream
{{- end }}

  clusters:
    - name: ext-proc
      type: STATIC
      connect_timeout: 0.2s
      http2_protocol_options: {}
      load_assignment:
        cluster_name: ext-proc
        endpoints:
          - lb_endpoints:
              - endpoint:
                  address:
                    socket_address: { address: 127.0.0.1, port_value: {{.ExtProcPort}} }

    - name: dynamic_forward_proxy_cluster
      connect_timeout: 2s
      cluster_type:
        name: envoy.clusters.dynamic_forward_proxy
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.clusters.dynamic_forward_proxy.v3.ClusterConfig
          dns_cache_config:
            name: dfp_cache
      transport_socket:
        name: envoy.transport_sockets.tls
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext
          common_tls_context:
            validation_context:
              trusted_ca:
                filename: {{.TrustedCAFile}}

{{- if .KafkaEnabled }}
    - name: kafka_upstream
      connect_timeout: 2s
      type: ORIGINAL_DST
      lb_policy: CLUSTER_PROVIDED
      transport_socket:
        name: envoy.transport_sockets.tls
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext
          common_tls_context:
            tls_certificates:
              - certificate_chain: { filename: {{.KafkaClientCert}} }
                private_key:       { filename: {{.KafkaClientKey}} }
            validation_context:
              trusted_ca: { filename: {{.KafkaCACert}} }
{{- end }}
`
	data := map[string]any{
		"NodeID":          strings.TrimSpace(c.App.Name) + "-egress",
		"EnvoyHTTPPort":   c.Ports.EnvoyHTTPListener,
		"EnvoyKafkaPort":  c.Ports.EnvoyKafkaListener,
		"ExtProcPort":     c.Ports.ExtProcGRPC,
		"DFPFamily":       c.HTTP.DFP.DNSLookupFamily,
		"DFPMaxHosts":     c.HTTP.DFP.MaxHosts,
		"TrustedCAFile":   c.HTTP.TrustedCAFile,
		"ForgeRockEnabled": c.HTTP.ForgeRock.Enabled,
		"ExtProcTimeout":  c.HTTP.ForgeRock.ExtProcTimeout,
		"KafkaEnabled":    c.Kafka.Enabled,
		"KafkaClientCert": c.Kafka.TLS.ClientCert,
		"KafkaClientKey":  c.Kafka.TLS.ClientKey,
		"KafkaCACert":     c.Kafka.TLS.CACert,
	}
	t, err := template.New("envoy").Option("missingkey=error").Parse(tpl)
	if err != nil {
		return "", err
	}
	var buf bytes.Buffer
	if err := t.Execute(&buf, data); err != nil {
		return "", err
	}
	return strings.TrimSpace(buf.String()) + "\n", nil
}


⸻

A6) cmd/egress-init/main.go (init binary)

package main

import (
	"flag"
	"fmt"
	"os"
	"path/filepath"

	"example.com/egress-injector-webhook/internal/ipt"
	"example.com/egress-injector-webhook/internal/policy"
	"example.com/egress-injector-webhook/internal/render"
)

func main() {
	cfgPath := flag.String("config", "/etc/egress/egress.yaml", "path to egress.yaml")
	outEnvoy := flag.String("out-envoy", "/work/envoy/envoy.yaml", "output envoy.yaml")
	envoyUID := flag.Int("envoy-uid", envInt("ENVOY_UID", 1337), "envoy uid")
	extprocUID := flag.Int("extproc-uid", envInt("EXTPROC_UID", 1338), "ext-proc uid")
	flag.Parse()

	c, err := policy.Load(*cfgPath)
	must(err)

	y, err := render.EnvoyYAML(c)
	must(err)
	must(writeAtomic(*outEnvoy, []byte(y)))

	must(ipt.Install(ipt.Params{
		EnvoyUID:          *envoyUID,
		ExtProcUID:        *extprocUID,
		EnvoyHTTPPort:     c.Ports.EnvoyHTTPListener,
		EnvoyKafkaPort:    c.Ports.EnvoyKafkaListener,
		HTTPInterceptPort: c.HTTP.InterceptPort,
		KafkaPorts:        c.Kafka.Ports,
	}))
	fmt.Println("egress-init: rendered envoy.yaml and installed iptables")
}

func envInt(k string, def int) int {
	v := os.Getenv(k)
	if v == "" {
		return def
	}
	var n int
	if _, err := fmt.Sscanf(v, "%d", &n); err != nil {
		return def
	}
	return n
}

func writeAtomic(path string, b []byte) error {
	dir := filepath.Dir(path)
	if err := os.MkdirAll(dir, 0o755); err != nil {
		return err
	}
	tmp := path + ".tmp"
	if err := os.WriteFile(tmp, b, 0o644); err != nil {
		return err
	}
	return os.Rename(tmp, path)
}

func must(err error) {
	if err != nil {
		fmt.Fprintln(os.Stderr, "ERROR:", err)
		os.Exit(1)
	}
}


⸻

A7) cmd/webhook/main.go (mutating webhook)

This injects the init container + sidecars and mounts.

package main

import (
	"crypto/tls"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"strings"

	admv1 "k8s.io/api/admission/v1"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

const (
	annEnabled  = "egress.mycorp.io/enabled"
	annInjected = "egress.mycorp.io/injected"

	annConfigMap        = "egress.mycorp.io/configmap"
	annKafkaTLSSecret   = "egress.mycorp.io/kafka-tls-secret"
	annForgeRockSecret  = "egress.mycorp.io/forgerock-secret"

	annEnvoyImage   = "egress.mycorp.io/envoy-image"
	annExtProcImage = "egress.mycorp.io/extproc-image"
	annInitImage    = "egress.mycorp.io/init-image"
)

type PatchOp struct {
	Op    string      `json:"op"`
	Path  string      `json:"path"`
	Value interface{} `json:"value,omitempty"`
}

func main() {
	mux := http.NewServeMux()
	mux.HandleFunc("/mutate", handleMutate)
	mux.HandleFunc("/healthz", func(w http.ResponseWriter, _ *http.Request) { w.WriteHeader(200) })

	addr := getenv("LISTEN_ADDR", ":8443")
	certFile := getenv("TLS_CERT_FILE", "/tls/tls.crt")
	keyFile := getenv("TLS_KEY_FILE", "/tls/tls.key")

	srv := &http.Server{
		Addr:    addr,
		Handler: mux,
		TLSConfig: &tls.Config{
			MinVersion: tls.VersionTLS12,
		},
	}
	log.Printf("webhook listening on %s", addr)
	log.Fatal(srv.ListenAndServeTLS(certFile, keyFile))
}

func handleMutate(w http.ResponseWriter, r *http.Request) {
	body, err := io.ReadAll(r.Body)
	if err != nil {
		http.Error(w, "read body", 400)
		return
	}

	var review admv1.AdmissionReview
	if err := json.Unmarshal(body, &review); err != nil {
		http.Error(w, "bad admission review", 400)
		return
	}
	req := review.Request
	if req == nil {
		http.Error(w, "missing request", 400)
		return
	}

	if req.Kind.Kind != "Pod" || req.Operation != admv1.Create {
		writeReview(w, allow(req.UID))
		return
	}

	var pod corev1.Pod
	if err := json.Unmarshal(req.Object.Raw, &pod); err != nil {
		writeReview(w, deny(req.UID, fmt.Sprintf("decode pod: %v", err)))
		return
	}

	anns := pod.GetAnnotations()
	if anns == nil {
		anns = map[string]string{}
	}

	if strings.ToLower(anns[annEnabled]) != "true" || strings.ToLower(anns[annInjected]) == "true" {
		writeReview(w, allow(req.UID))
		return
	}

	cm := strings.TrimSpace(anns[annConfigMap])
	kafkaSecret := strings.TrimSpace(anns[annKafkaTLSSecret])
	frSecret := strings.TrimSpace(anns[annForgeRockSecret])
	if cm == "" || kafkaSecret == "" || frSecret == "" {
		writeReview(w, deny(req.UID, "missing required egress annotations (configmap/kafka-tls-secret/forgerock-secret)"))
		return
	}

	envoyImage := defaultIfEmpty(anns[annEnvoyImage], "envoyproxy/envoy:v1.31.0")
	extProcImage := defaultIfEmpty(anns[annExtProcImage], "myrepo/ext-proc:1.0.0")
	initImage := defaultIfEmpty(anns[annInitImage], "myrepo/egress-init:1.0.0")

	patch, err := buildPatch(&pod, cm, kafkaSecret, frSecret, envoyImage, extProcImage, initImage)
	if err != nil {
		writeReview(w, deny(req.UID, err.Error()))
		return
	}

	patchBytes, _ := json.Marshal(patch)
	writeReview(w, &admv1.AdmissionResponse{
		UID:       req.UID,
		Allowed:   true,
		Patch:     patchBytes,
		PatchType: patchTypePtr(admv1.PatchTypeJSONPatch),
	})
}

func buildPatch(pod *corev1.Pod, cmName, kafkaSecret, frSecret, envoyImage, extProcImage, initImage string) ([]PatchOp, error) {
	var ops []PatchOp

	if pod.Annotations == nil {
		ops = append(ops, PatchOp{Op: "add", Path: "/metadata/annotations", Value: map[string]string{}})
	}
	ops = append(ops, PatchOp{Op: "add", Path: "/metadata/annotations/" + escapeJSONPointer(annInjected), Value: "true"})

	if pod.Spec.Volumes == nil {
		ops = append(ops, PatchOp{Op: "add", Path: "/spec/volumes", Value: []corev1.Volume{}})
	}
	ops = append(ops, PatchOp{Op: "add", Path: "/spec/volumes/-", Value: corev1.Volume{
		Name: "egress-config",
		VolumeSource: corev1.VolumeSource{
			ConfigMap: &corev1.ConfigMapVolumeSource{LocalObjectReference: corev1.LocalObjectReference{Name: cmName}},
		},
	}})
	ops = append(ops, PatchOp{Op: "add", Path: "/spec/volumes/-", Value: corev1.Volume{
		Name:         "envoy-runtime",
		VolumeSource: corev1.VolumeSource{EmptyDir: &corev1.EmptyDirVolumeSource{}},
	}})
	ops = append(ops, PatchOp{Op: "add", Path: "/spec/volumes/-", Value: corev1.Volume{
		Name: "kafka-certs",
		VolumeSource: corev1.VolumeSource{
			Secret: &corev1.SecretVolumeSource{SecretName: kafkaSecret},
		},
	}})

	if pod.Spec.InitContainers == nil {
		ops = append(ops, PatchOp{Op: "add", Path: "/spec/initContainers", Value: []corev1.Container{}})
	}
	ops = append(ops, PatchOp{Op: "add", Path: "/spec/initContainers/-", Value: corev1.Container{
		Name:    "egress-init",
		Image:   initImage,
		Command: []string{"/egress-init"},
		Args: []string{
			"-config=/etc/egress/egress.yaml",
			"-out-envoy=/work/envoy/envoy.yaml",
		},
		SecurityContext: &corev1.SecurityContext{
			RunAsUser: ptrI64(0),
			Capabilities: &corev1.Capabilities{
				Add: []corev1.Capability{"NET_ADMIN"},
			},
			AllowPrivilegeEscalation: ptrB(false),
		},
		Env: []corev1.EnvVar{
			{Name: "ENVOY_UID", Value: "1337"},
			{Name: "EXTPROC_UID", Value: "1338"},
		},
		VolumeMounts: []corev1.VolumeMount{
			{Name: "egress-config", MountPath: "/etc/egress", ReadOnly: true},
			{Name: "envoy-runtime", MountPath: "/work"},
		},
	}})

	if len(pod.Spec.Containers) == 0 {
		return nil, fmt.Errorf("pod has no containers")
	}

	ops = append(ops, PatchOp{Op: "add", Path: "/spec/containers/-", Value: corev1.Container{
		Name:  "ext-proc",
		Image: extProcImage,
		SecurityContext: &corev1.SecurityContext{
			RunAsUser:                ptrI64(1338),
			RunAsNonRoot:             ptrB(true),
			ReadOnlyRootFilesystem:   ptrB(true),
			AllowPrivilegeEscalation: ptrB(false),
		},
		Env: []corev1.EnvVar{
			{Name: "EGRESS_POLICY_FILE", Value: "/etc/egress/egress.yaml"},
			{Name: "EXTPROC_LISTEN", Value: "127.0.0.1:9000"},
			{
				Name: "FORGEROCK_CLIENT_SECRET",
				ValueFrom: &corev1.EnvVarSource{
					SecretKeyRef: &corev1.SecretKeySelector{
						LocalObjectReference: corev1.LocalObjectReference{Name: frSecret},
						Key:                  "client_secret",
					},
				},
			},
		},
		Ports: []corev1.ContainerPort{{Name: "grpc", ContainerPort: 9000}},
		VolumeMounts: []corev1.VolumeMount{
			{Name: "egress-config", MountPath: "/etc/egress", ReadOnly: true},
		},
	}})

	ops = append(ops, PatchOp{Op: "add", Path: "/spec/containers/-", Value: corev1.Container{
		Name: "envoy",
		Image: envoyImage,
		Args: []string{"-c", "/etc/envoy/envoy.yaml", "--log-level", "info"},
		SecurityContext: &corev1.SecurityContext{
			RunAsUser:                ptrI64(1337),
			RunAsNonRoot:             ptrB(true),
			ReadOnlyRootFilesystem:   ptrB(true),
			AllowPrivilegeEscalation: ptrB(false),
		},
		Ports: []corev1.ContainerPort{
			{Name: "egress-http", ContainerPort: 15001},
			{Name: "egress-kafka", ContainerPort: 15006},
			{Name: "admin", ContainerPort: 9901},
		},
		VolumeMounts: []corev1.VolumeMount{
			{Name: "envoy-runtime", MountPath: "/etc/envoy", ReadOnly: true},
			{Name: "kafka-certs", MountPath: "/etc/envoy/certs", ReadOnly: true},
		},
	}})

	return ops, nil
}

func writeReview(w http.ResponseWriter, resp *admv1.AdmissionResponse) {
	out := admv1.AdmissionReview{
		TypeMeta: metav1.TypeMeta{APIVersion: "admission.k8s.io/v1", Kind: "AdmissionReview"},
		Response: resp,
	}
	b, _ := json.Marshal(out)
	w.Header().Set("Content-Type", "application/json")
	_, _ = w.Write(b)
}

func allow(uid string) *admv1.AdmissionResponse { return &admv1.AdmissionResponse{UID: uid, Allowed: true} }
func deny(uid, msg string) *admv1.AdmissionResponse {
	return &admv1.AdmissionResponse{UID: uid, Allowed: false, Result: &metav1.Status{Message: msg}}
}

func escapeJSONPointer(s string) string {
	s = strings.ReplaceAll(s, "~", "~0")
	s = strings.ReplaceAll(s, "/", "~1")
	return s
}
func getenv(k, def string) string {
	v := strings.TrimSpace(os.Getenv(k))
	if v == "" { return def }
	return v
}
func defaultIfEmpty(v, def string) string {
	v = strings.TrimSpace(v)
	if v == "" { return def }
	return v
}
func patchTypePtr(pt admv1.PatchType) *admv1.PatchType { return &pt }
func ptrI64(v int64) *int64 { return &v }
func ptrB(v bool) *bool { return &v }


⸻

A8) Dockerfiles

Dockerfile.webhook

FROM golang:1.22 AS build
WORKDIR /src
COPY go.mod go.sum ./
RUN go mod download
COPY . .
RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o /out/webhook ./cmd/webhook

FROM gcr.io/distroless/static:nonroot
COPY --from=build /out/webhook /webhook
USER 65532
ENTRYPOINT ["/webhook"]

Dockerfile.egress-init  (needs iptables in image)

FROM golang:1.22 AS build
WORKDIR /src
COPY go.mod go.sum ./
RUN go mod download
COPY . .
RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o /out/egress-init ./cmd/egress-init

FROM alpine:3.20
RUN apk add --no-cache iptables
COPY --from=build /out/egress-init /egress-init
USER 0
ENTRYPOINT ["/egress-init"]


⸻

Repo B — egress-extproc

What this repo contains
	•	ext-proc gRPC server implementing Envoy External Processing
	•	Reads the same egress.yaml (mounted ConfigMap) from /etc/egress/egress.yaml
	•	Implements:
	•	longest-prefix match on :path
	•	token caching keyed by rule profile/scope/audience
	•	ForgeRock client_credentials token fetch
	•	injects Authorization header

This repo does not contain webhook or init code.

⸻

B1) Repo B layout

egress-extproc/
  cmd/
    extproc/
      main.go
  internal/
    policy/
      policy.go
    tokens/
      tokens.go
  Dockerfile
  go.mod
  README.md


⸻

B2) Repo B go.mod

module example.com/egress-extproc

go 1.22

require (
	github.com/envoyproxy/go-control-plane v0.13.4
	golang.org/x/sync v0.10.0
	google.golang.org/grpc v1.66.2
	gopkg.in/yaml.v3 v3.0.1
)


⸻

B3) internal/policy/policy.go (subset schema for ext-proc)

package policy

import (
	"os"
	"time"

	"gopkg.in/yaml.v3"
)

type Rule struct {
	Profile  string            `yaml:"profile"`
	Prefix   string            `yaml:"prefix"`
	Scope    string            `yaml:"scope"`
	Audience string            `yaml:"audience"`
	Extra    map[string]string `yaml:"extra,omitempty"`
}

type Config struct {
	App struct {
		Name string `yaml:"name"`
	} `yaml:"app"`

	HTTP struct {
		Allow struct {
			DomainSuffixes []string `yaml:"domain_suffixes"`
		} `yaml:"allow"`

		ForgeRock struct {
			Enabled bool   `yaml:"enabled"`
			FailMode string `yaml:"fail_mode"`

			Bypass struct {
				AuthorityContains []string `yaml:"authority_contains"`
			} `yaml:"bypass"`

			TokenEndpoint string `yaml:"token_endpoint"`

			ClientAuth struct {
				ClientID        string `yaml:"client_id"`
				ClientSecretEnv string `yaml:"client_secret_env"`
			} `yaml:"client_auth"`

			Rules []Rule `yaml:"rules"`
		} `yaml:"forgerock"`
	} `yaml:"http"`
}

func Load(path string) (*Config, error) {
	b, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	var c Config
	if err := yaml.Unmarshal(b, &c); err != nil {
		return nil, err
		if c.HTTP.ForgeRock.FailMode == "" {
			c.HTTP.ForgeRock.FailMode = "closed"
		}
	}
	if c.HTTP.ForgeRock.FailMode == "" {
		c.HTTP.ForgeRock.FailMode = "closed"
	}
	return &c, nil
}

func ModTime(path string) (time.Time, error) {
	st, err := os.Stat(path)
	if err != nil {
		return time.Time{}, err
	}
	return st.ModTime(), nil
}


⸻

B4) internal/tokens/tokens.go (cache + ForgeRock fetch)

Use the one from earlier (same as in my previous message’s tokens.go). If you want it again, say so and I’ll paste it verbatim — it’s long but straightforward.

⸻

B5) cmd/extproc/main.go (ext-proc server)

Use the ext-proc code from the earlier message’s cmd/extproc/main.go (it’s already fully standalone). It reads:
	•	EGRESS_POLICY_FILE=/etc/egress/egress.yaml
	•	FORGEROCK_CLIENT_SECRET from env (from Secret)

⸻

B6) Repo B Dockerfile

FROM golang:1.22 AS build
WORKDIR /src
COPY go.mod go.sum ./
RUN go mod download
COPY . .
RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o /out/ext-proc ./cmd/extproc

FROM gcr.io/distroless/static:nonroot
COPY --from=build /out/ext-proc /ext-proc
USER 1338
ENTRYPOINT ["/ext-proc"]


⸻

How you wire them together in Kubernetes

Per-app egress.yaml ConfigMap
	•	Stored by app/team (or generated by your platform pipeline)
	•	Mounted by webhook into the app pod at /etc/egress/egress.yaml

Webhook injection annotations (on the app workload)

metadata:
  annotations:
    egress.mycorp.io/enabled: "true"
    egress.mycorp.io/configmap: "egress-config-orders"
    egress.mycorp.io/kafka-tls-secret: "orders-kafka-mtls"
    egress.mycorp.io/forgerock-secret: "forgerock-client-orders"
    egress.mycorp.io/envoy-image: "envoyproxy/envoy:v1.31.0"
    egress.mycorp.io/extproc-image: "myrepo/ext-proc:1.0.0"
    egress.mycorp.io/init-image: "myrepo/egress-init:1.0.0"

Reading config + shared path
	•	ext-proc reads /etc/egress/egress.yaml (ConfigMap mount)
	•	egress-init reads /etc/egress/egress.yaml and writes /work/envoy/envoy.yaml
	•	Envoy reads /etc/envoy/envoy.yaml (emptyDir mount)

⸻

One thing to confirm before you push

In Repo B, the ext-proc code expects FORGEROCK_CLIENT_SECRET env var. In Repo A webhook, I’m setting that from the Secret key client_secret into env var FORGEROCK_CLIENT_SECRET. That’s consistent.

⸻

If you want, I can also provide:
	•	a minimal egress.yaml example that includes both Kafka + ForgeRock rules (prefix match) and domain suffix allowlist
	•	the full deploy/webhook/*.yaml with cert-manager-managed TLS for the webhook and auto CA bundle injection (so you can kubectl apply the whole thing cleanly).